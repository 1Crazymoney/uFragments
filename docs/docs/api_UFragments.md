---
id: UFragments
title: UFragments
---

<div class="contract-doc"><div class="contract"><h2 class="contract-header"><span class="contract-kind">contract</span> UFragments</h2><p class="base-contracts"><span>is</span> <a href="es_openzeppelin-solidity_contracts_token_ERC20_DetailedERC20.html">DetailedERC20</a><span>, </span><a href="es_openzeppelin-solidity_contracts_ownership_Ownable.html">Ownable</a></p><p class="description">This is a simplified implementation of the full protocol @ https://fragments.org/protocol uFragments operates symmetrically on expansion and contraction. It will both split and combine coins to maintain a stable unit price. * @dev uFragment balances are internally represented with a hidden denomination, &#x27;gons&#x27;. We support splitting the currency in expansion and combining the currency on contraction by changing the exchange rate between the hidden &#x27;gons&#x27; and the public &#x27;fragments&#x27;. This exchange rate is determined by the internal properties &#x27;GONS&#x27; and &#x27;totalSupply_&#x27;. *      Anytime there is division, there is a risk of numerical instability from rounding errors. In order to minimize this risk, we adhere to the following guidelines: - The conversion rate adopted is the number of gons that equals 1 fragment. The inverse rate must not be used--GONS is always the numerator and totalSupply_ is always the denominator. (i.e. If you want to convert gons to fragments instead of multiplying by the inverse rate, you should divide by the normal rate) - Gon balances converted into fragments are always rounded down (truncated). - Fragment values converted to gon values (such as in transfers) are chosen such at the below guarantees are upheld. *      We make the following guarantees: - If address &#x27;A&#x27; transfers x fragments to address &#x27;B&#x27;. A&#x27;s resulting external balance will be decreased by precisely x fragments, and B&#x27;s external balance will be precisely increased by x fragments. *     We do not guarantee that the sum of all balances equals the result of calling totalSupply(). This is because, for any conversion function &#x27;f()&#x27; that has non-zero rounding error, f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn). *     &#x27;The Introduction of the Euro and the Rounding of Currency Amounts (1999)&#x27; is a good starting reference for practices related to currency conversions. http://ec.europa.eu/economy_finance/publications/pages/publication1224_en.pdf.</p><div class="source">Source: <a href="git+https://github.com/frgprotocol/uFragments/blob/v0.0.1/contracts/UFragments.sol" target="_blank">UFragments.sol</a></div></div><div class="index"><h2>Index</h2><ul><li><a href="UFragments.html#Rebase">Rebase</a></li><li><a href="UFragments.html#RebasePaused">RebasePaused</a></li><li><a href="UFragments.html#TokenPaused">TokenPaused</a></li><li><a href="UFragments.html#allowance">allowance</a></li><li><a href="UFragments.html#approve">approve</a></li><li><a href="UFragments.html#balanceOf">balanceOf</a></li><li><a href="UFragments.html#decreaseApproval">decreaseApproval</a></li><li><a href="UFragments.html#">fallback</a></li><li><a href="UFragments.html#increaseApproval">increaseApproval</a></li><li><a href="UFragments.html#onlyMonetaryPolicy">onlyMonetaryPolicy</a></li><li><a href="UFragments.html#rebase">rebase</a></li><li><a href="UFragments.html#setMonetaryPolicy">setMonetaryPolicy</a></li><li><a href="UFragments.html#setRebasePaused">setRebasePaused</a></li><li><a href="UFragments.html#setTokenPaused">setTokenPaused</a></li><li><a href="UFragments.html#totalSupply">totalSupply</a></li><li><a href="UFragments.html#transfer">transfer</a></li><li><a href="UFragments.html#transferFrom">transferFrom</a></li><li><a href="UFragments.html#whenRebaseNotPaused">whenRebaseNotPaused</a></li><li><a href="UFragments.html#whenTokenNotPaused">whenTokenNotPaused</a></li></ul></div><div class="reference"><h2>Reference</h2><div class="events"><h3>Events</h3><ul><li><div class="item event"><span id="Rebase" class="anchor-marker"></span><h4 class="name">Rebase</h4><div class="body"><code class="signature">event <strong>Rebase</strong><span>(uint256 epoch, uint256 totalSupply) </span></code><hr/><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>epoch</code> - uint256</div><div><code>totalSupply</code> - uint256</div></dd></dl></div></div></li><li><div class="item event"><span id="RebasePaused" class="anchor-marker"></span><h4 class="name">RebasePaused</h4><div class="body"><code class="signature">event <strong>RebasePaused</strong><span>(bool paused) </span></code><hr/><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>paused</code> - bool</div></dd></dl></div></div></li><li><div class="item event"><span id="TokenPaused" class="anchor-marker"></span><h4 class="name">TokenPaused</h4><div class="body"><code class="signature">event <strong>TokenPaused</strong><span>(bool paused) </span></code><hr/><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>paused</code> - bool</div></dd></dl></div></div></li></ul></div><div class="modifiers"><h3>Modifiers</h3><ul><li><div class="item modifier"><span id="onlyMonetaryPolicy" class="anchor-marker"></span><h4 class="name">onlyMonetaryPolicy</h4><div class="body"><code class="signature">modifier <strong>onlyMonetaryPolicy</strong><span>() </span></code><hr/></div></div></li><li><div class="item modifier"><span id="whenRebaseNotPaused" class="anchor-marker"></span><h4 class="name">whenRebaseNotPaused</h4><div class="body"><code class="signature">modifier <strong>whenRebaseNotPaused</strong><span>() </span></code><hr/></div></div></li><li><div class="item modifier"><span id="whenTokenNotPaused" class="anchor-marker"></span><h4 class="name">whenTokenNotPaused</h4><div class="body"><code class="signature">modifier <strong>whenTokenNotPaused</strong><span>() </span></code><hr/></div></div></li></ul></div><div class="functions"><h3>Functions</h3><ul><li><div class="item function"><span id="allowance" class="anchor-marker"></span><h4 class="name">allowance</h4><div class="body"><code class="signature">function <strong>allowance</strong><span>(address owner, address spender) </span><span>public </span><span>view </span><span>returns  (uint256) </span></code><hr/><div class="description"><p>Function to check the amount of tokens that an owner has allowed to a spender.</p></div><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>owner</code> - The address which owns the funds.</div><div><code>spender</code> - The address which will spend the funds.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>The number of tokens still available for the spender.</dd></dl></div></div></li><li><div class="item function"><span id="approve" class="anchor-marker"></span><h4 class="name">approve</h4><div class="body"><code class="signature">function <strong>approve</strong><span>(address spender, uint256 value) </span><span>public </span><span>returns  (bool) </span></code><hr/><div class="description"><p>Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender&#x27;s allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="UFragments.html#whenTokenNotPaused">whenTokenNotPaused </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>spender</code> - The address which will spend the funds.</div><div><code>value</code> - The amount of tokens to be spent.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>bool</dd></dl></div></div></li><li><div class="item function"><span id="balanceOf" class="anchor-marker"></span><h4 class="name">balanceOf</h4><div class="body"><code class="signature">function <strong>balanceOf</strong><span>(address who) </span><span>public </span><span>view </span><span>returns  (uint256) </span></code><hr/><dl><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>who</code> - The address to query.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>The balance of the specified address.</dd></dl></div></div></li><li><div class="item function"><span id="decreaseApproval" class="anchor-marker"></span><h4 class="name">decreaseApproval</h4><div class="body"><code class="signature">function <strong>decreaseApproval</strong><span>(address spender, uint256 subtractedValue) </span><span>public </span><span>returns  (bool) </span></code><hr/><div class="description"><p>Decrease the amount of tokens that an owner has allowed to a spender. * approve should be called when allowed[spender] == 0. To decrement allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="UFragments.html#whenTokenNotPaused">whenTokenNotPaused </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>spender</code> - The address which will spend the funds.</div><div><code>subtractedValue</code> - The amount of tokens to decrease the allowance by.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>bool</dd></dl></div></div></li><li><div class="item function"><span id="fallback" class="anchor-marker"></span><h4 class="name">fallback</h4><div class="body"><code class="signature">function <strong></strong><span>() </span><span>public </span></code><hr/></div></div></li><li><div class="item function"><span id="increaseApproval" class="anchor-marker"></span><h4 class="name">increaseApproval</h4><div class="body"><code class="signature">function <strong>increaseApproval</strong><span>(address spender, uint256 addedValue) </span><span>public </span><span>returns  (bool) </span></code><hr/><div class="description"><p>Increase the amount of tokens that an owner has allowed to a spender. * approve should be called when allowed[spender] == 0. To increment allowed value is better to use this function to avoid 2 calls (and wait until the first transaction is mined) From MonolithDAO Token.sol.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="UFragments.html#whenTokenNotPaused">whenTokenNotPaused </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>spender</code> - The address which will spend the funds.</div><div><code>addedValue</code> - The amount of tokens to increase the allowance by.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>bool</dd></dl></div></div></li><li><div class="item function"><span id="rebase" class="anchor-marker"></span><h4 class="name">rebase</h4><div class="body"><code class="signature">function <strong>rebase</strong><span>(uint256 epoch, int256 supplyDelta) </span><span>external </span></code><hr/><div class="description"><p>Notifies Fragments contract about a new rebase cycle.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="UFragments.html#onlyMonetaryPolicy">onlyMonetaryPolicy </a><a href="UFragments.html#whenRebaseNotPaused">whenRebaseNotPaused </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>epoch</code> - uint256</div><div><code>supplyDelta</code> - The number of new fragment tokens to add into circulation via expansion.</div></dd></dl></div></div></li><li><div class="item function"><span id="setMonetaryPolicy" class="anchor-marker"></span><h4 class="name">setMonetaryPolicy</h4><div class="body"><code class="signature">function <strong>setMonetaryPolicy</strong><span>(address monetaryPolicy_) </span><span>external </span></code><hr/><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="es_openzeppelin-solidity_contracts_ownership_Ownable.html#onlyOwner">onlyOwner </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>monetaryPolicy_</code> - The address of the monetary policy contract to use for authz.</div></dd></dl></div></div></li><li><div class="item function"><span id="setRebasePaused" class="anchor-marker"></span><h4 class="name">setRebasePaused</h4><div class="body"><code class="signature">function <strong>setRebasePaused</strong><span>(bool paused) </span><span>external </span></code><hr/><div class="description"><p>Pauses or unpauses the execution of rebase operations.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="es_openzeppelin-solidity_contracts_ownership_Ownable.html#onlyOwner">onlyOwner </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>paused</code> - Pauses rebase operations if this is true.</div></dd></dl></div></div></li><li><div class="item function"><span id="setTokenPaused" class="anchor-marker"></span><h4 class="name">setTokenPaused</h4><div class="body"><code class="signature">function <strong>setTokenPaused</strong><span>(bool paused) </span><span>external </span></code><hr/><div class="description"><p>Pauses or unpauses execution of ERC-20 transactions.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="es_openzeppelin-solidity_contracts_ownership_Ownable.html#onlyOwner">onlyOwner </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>paused</code> - Pauses ERC-20 transactions if this is true.</div></dd></dl></div></div></li><li><div class="item function"><span id="totalSupply" class="anchor-marker"></span><h4 class="name">totalSupply</h4><div class="body"><code class="signature">function <strong>totalSupply</strong><span>() </span><span>public </span><span>view </span><span>returns  (uint256) </span></code><hr/><dl><dt><span class="label-return">Returns:</span></dt><dd>The total number of fragments.</dd></dl></div></div></li><li><div class="item function"><span id="transfer" class="anchor-marker"></span><h4 class="name">transfer</h4><div class="body"><code class="signature">function <strong>transfer</strong><span>(address to, uint256 value) </span><span>public </span><span>returns  (bool) </span></code><hr/><div class="description"><p>Transfer tokens to a specified address.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="UFragments.html#whenTokenNotPaused">whenTokenNotPaused </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>to</code> - The address to transfer to.</div><div><code>value</code> - The amount to be transferred.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>True on success, false otherwise.</dd></dl></div></div></li><li><div class="item function"><span id="transferFrom" class="anchor-marker"></span><h4 class="name">transferFrom</h4><div class="body"><code class="signature">function <strong>transferFrom</strong><span>(address from, address to, uint256 value) </span><span>public </span><span>returns  (bool) </span></code><hr/><div class="description"><p>Transfer tokens from one address to another.</p></div><dl><dt><span class="label-modifiers">Modifiers:</span></dt><dd><a href="UFragments.html#whenTokenNotPaused">whenTokenNotPaused </a></dd><dt><span class="label-parameters">Parameters:</span></dt><dd><div><code>from</code> - The address you want to send tokens from.</div><div><code>to</code> - The address you want to transfer to.</div><div><code>value</code> - The amount of tokens to be transferred.</div></dd><dt><span class="label-return">Returns:</span></dt><dd>bool</dd></dl></div></div></li></ul></div></div></div>
